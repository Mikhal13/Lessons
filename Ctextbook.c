/* Программа Ctextbook */
/* Это учебное пособие с примерами для начального обучения использования инструмментов языка программирования Си. */
/* При написании для компиляции использовался GCC из пакета MinGW. */
/* Код набирался в среде Notepad++ с синтаксисом С. */
/* Знаки табуляции заменены на 4 пробела для однозначности выравнивания текста в разных редакторах. */


#include <stdio.h>                  /* Директива #include сообщает компилятору, что необходимо включить в эту программу код, находящийся в файле stdio.h. */
                                    /* Файл stdio.h является одной из библиотек, где прописаны основные функции ввода-вывода, глобальные константы и переменные. */
                                    /* Код файла stdio.h написан на Си. */
#include <stdlib.h>
                                    
#define LOWER -20                   /* Директива #define сообщает компилятору, что при нахождении кода LOWER его следует заменить на -20. */
#define UPPER 300                   /*                                                                 UPPER следует заменить на 300. */
#define STEP 20                     /*                                                                 STEP его следует заменить на 20. */
#define MAXWORD 20                  /* Максимальное количество символов в слове. */
#define MAXSTRING 400               /* Максимальное количество символов в строке входного потока. */
                                    /* LOWER, UPPER, STEP MAXWORD, MAXSTRING называются макросами. Их принято писать прописными (большими) буквами, что бы отличать от переменных и констант. */
                                    /* Объявление глобальных переменных. */
                                    
const int       CT = 0;                                     /* Объявляем константу CT. CT занимает ячейку памяти, но не может быть изменена. */

char            c_var = 'A';                                /* Объявляем переменную как знаковую символ. Переменная занимает 1 байт и принимает значения от -128 до 127. */
                                                            /* Здесь же инициализируем переменную значением 65, что соответствует символу "A". */
                                                            /* Нечитаемые (управляющие) символы указываются либо через обратную косую: */
                                                            /* char            c_var = '\t'; - горизонтальная табуляция; */
                                                            /* либо непосредственно значением кода: */
                                                            /* char            c_var = 12; - возврат корретки. */

short            s_var = 32767;                             /* Объявляем переменную как целое знаковое коротко. Переменная занимает 2 байта и принимает значения от -32768 до 32767. */                                   
                                                            /* Здесь же инициализируем переменную значением 32767. */

int              i_var = 2147483647;                        /* Объявляем переменную как целое знаковое. Переменная занимает 4 байта и принимает значения от -2147483648 до 2147483647. */
                                                            /* Здесь же инициализируем переменную значением 2147483647. */

long long int    l_var = 9223372036854775807;               /* Объявляем переменную как целое знаковое. Переменная занимает 8 байта и принимает значения от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807. */
                                                            /* Здесь же инициализируем переменную значением 9 223 372 036 854 775 807. */
                                    
float            f_var = 3.402823466e38;                    /* Объявляем переменную как знаковое с плавающей точкой. Переменная занимает 4 байта и принимает значения от ±1.175494351*10^38 до ±3.402823466*10^38. */
                                                            /* Здесь же инициализируем переменную значением 3.4*10^38. */

double           d_var = 1.7976931348623158e308;            /* Объявляем переменную как знаковое с плавающей точкой. Переменная занимает 8 байта и принимает значения от ±2.2250738585072014*10^-324 до ±1.7976931348623158*10^308. */
                                                            /* Здесь же инициализируем переменную значением 1.7976931348623158*10^308. */

unsigned char    uc_var = 'A';                              /* Объявляем переменную как беззнаковую символ. Переменная занимает 1 байт и принимает значения от 0 до 255. */
                                                            /* Здесь же инициализируем переменную значением 65, что соответствует символу "A". */

unsigned short  us_var = 65535;                             /* Объявляем переменную как целое беззнаковое короткое. Переменная занимает 2 байта и принимает значения от 0 до 65535. */
                                                            /* Здесь же инициализируем переменную значением 65535. */

unsigned int    ui_var = 4294967295;                        /* Объявляем переменную как целое беззнаковое. Переменная занимает 4 байта и принимает значения от 0 до 4294967295. */
                                                            /* Здесь же инициализируем переменную значением 4294967295. */

unsigned long long int ul_var = 18446744073709551615;       /* Объявляем переменную как целое беззнаковое. Переменная занимает 8 байта и принимает значения от 0 до 18 446 744 073 709 551 615‬. */
                                                            /* Здесь же инициализируем переменную значением 18 446 744 073 709 551 615‬. */

                                                            /* Стандарт языка не определяет количество байт и границы значений перечисленных типов. */
                                                            /* Стандарт лишь определяет, что char < short < int < long < long long. */
                                                            /* Указание того, что число беззнаковое не меняет значение самого числа, а лишь указывает компилятору, как следует воспринимать это значение. */
                                                            /* Имена переменных принято писать строчными (маленькими) буквами. */
                                                            
enum            counter {NOL, CHETVERT, POLSTA} e_v = NOL;  /* Объявляем переменную e_v как перечисление counter, значения которого могут быть только NOL, CHETVERT или POLSTA и инициализируем её значением NOL. */
                                                            /* По факту e_v это номер элемента, который виден как осмысленное имя, что улутшает читабельность кода. */
enum            counter2 {NOL2, CHETVERT2, POLSTA2} e_v_2 = NOL2; /* Объявим другое перечисление для сравнения переменных e_v и e_v_2. */
                                                            

int             i_arr[3] = {0, 1, 2};                       /* Объявляем массив целых чисел из 3 элементов и инициализируем его: */
                                                            /* i_arr[0] = 0, i_arr[1] = 1, i_arr[2] = 2. */
                                                            /* При инициализации можно не указывать размерность массива, компилятор сам её вычислит: */
                                                            /* int  i_arr[] = {0, 1, 2}; */
                                                            /* Объявление int  i_arr[3] = {0, 1, ...}; создаст массив из трёх элементов, и инициализирует лишь первые 2 элемента i_arr[0] = 0, i_arr[1] = 1. */

short            s_arr[2][3] = {0, 1, 2, 3, 4, 5};          /* Объявляем массив целых чисел из 2 строк по 3 элемента и инициализируем его: */
                                                            /* s_arr[0][0] = 0, s_arr[0][1] = 1, s_arr[0][2] = 2. */
                                                            /* s_arr[1][0] = 3, s_arr[1][1] = 4, s_arr[1][2] = 5. */
                                                            
char            c_string[] = "abcdefgh";                    /* Объявляем массив (из девяти, так как компилятор добавляет в конце символ 0, означающий конец строки) символов и инициализируем его: */
                                                            /* c_string[0] = 'a', c_string[1] = 'b', ... c_string[8] = 'h', c_string[9] = 0. */
                                                            /* Что бы обрабатывать массив символов как строку, последний элемент должен содержать нечитаемый символ, код которого равен 0 (признак конца строки) */
                                                            /* Что бы, к примеру, третий элемент содержал обратную косую, надо записать: */
                                                            /* char c_string[] = "ab\\defgh"; */
char            *p_string = c_string;                       /* Объявление указателя на символьную переменную *p_string и инициализация его адресом первого элемента массива c_string */
/*              *p_string = &c_string[0]                       так же правильная инициализация */
                                                            
int             i = 10, j = 10, k = 10;                     /* i, j, k - вспомогательные переменные. */

struct bit_field                                            /* Объявляем структуру b_f типа struct bit_field, которая содержит три битовых поля. */
{
unsigned b1 : 1;                  /* b1 поле из одного бита и может принимать значения 0 или 1. */
unsigned b2 : 2;                  /* b2 поле из одного 2 бит и может принимать значения от 0 до 3. */
unsigned b3 : 3;                  /* b3 поле из одного 3 бит и может принимать значения от 0 до 7. */
} b_f;

union complex_type                                          /* Объявляем объединение с именем c_t и типом union complex_type, которое может являться переменной трёх разных типов. */
{
    char c_v;
    int i_v;
    double f_v;
} c_t;                                                      /* Знак ";" в конце объединения. */

void* ppp;
int m[13];
int *nmonth[13];
char *cmonth[] = {"NULL", "january", "Febuary", "march", "April", "june", "july", "August", "September", "October", "November", "December"};
int *ab;

void prestart()                                             /* Объявляем функцию prestart не имеющую аргументов и не возвращающую ничего. void - пустой тип */
{                                                           /* Строго говоря void prestart(void). */
    printf("Program starting\n");                           /* Вывод на экран надпись "Program starting" и перевод на следующую строку. */
    return;                                                 /* Возврат без результата. Строго говоря return(void); */
}

int finish()                                                /* Объявляем функцию finish не имеющую аргументов и возвращающую результат типа int. */
{                                                           /* Строго говоря int finish(void). */
    printf("Program finished\n");                           /* Вывод на экран надпись "Program finished" и перевод на следующую строку. */
    return 0;                                               /* Возврат результата 0 типа int. */
}

void prestart_finish()                                      /* Объявляем функцию prestart_finish не имеющую аргументов и не возвращающую ничего. void - пустой тип */
{                                                           /* Строго говоря void restart_finish(void). */
    printf("Secondary function for start or exit\n");       /* Вывод на экран надпись "Secondary function for start or exit" и перевод на следующую строку. */
    return;                                                 /* Возврат без результата. Строго говоря return(void); */
}

void lesson_1()                                             /* Первый урок. Типы, значения и видимость переменных, формат функции printf. */
{
int i = 0, j = 0;                                           /* i, j - вспомогательные локальные переменные. */
                                                            /* В данной процедуре они затеняют переменные i, j объявленные выше (строка 80) как глобальные. */
char frase[] = "hello, world";                              /* Фраза из 12 читаемых символов. */

float   f = 1234.56789;                                     /* Вспомогательная переменная. */
double  d = 1234.56789;                                     /* Вспомогательная переменная. */

    printf("Acquaint with printf function and check variables size, limits and visible.\n\n");
    k = printf("123\n");                                                                /* k = количество выведенных символов. */
    printf("Last string include %i symbols\n", k);                                      /* Печатает количество символов, выведенных в предыдущей строке. */
    getchar();                                                                          /* Ожидание ввода. Функция объявлена в библиотеке stdio.h. */
    printf("Variable i is local, because i = %i\n", i);                                 /* Печатает значение переменной i, подтверждая видимость локальной i, которая равна 0. */
    if (!j)                                                                             /* Если j==0, то : */
    {
        int i = 5;                                                                      /* Объявляется локальная в ветке "if" переменная i и инициализируется значением 5 и */
        printf("This variable i is local in this construction, because i = %i\n", i);   /* печатается её значение. */
    }
    printf("Variable i in last construction is finished, because i = %i\n", i);         /* Печатает значение переменной i, которая равна 0, подтверждая завершение существования локальной i в ветке if. */
    printf("Variable k is global, k = %i\n\n", k);                                      /* Печатает значение переменной k, которая равна 4, подтверждая видимость глобальных переменных при */
                                                                                        /* отсутствии объявления одноимённых локальных. */

    printf("Formats of function printf \n");                                            /* Демонстрация выравнивания печатного поля. */
    getchar();
    j = 5;
    printf("\n");
    printf(":%s:\n",frase);             /* Печатает всю фразу.                                                                      :hello, world:      */
    printf(":%10s:\n",frase);           /* Печатает не менее 10 символов фразы с выравниванием по правому краю.                     :hello, world:      */
    printf(":%.10s:\n",frase);          /* Печатает фразe в поле из 10 символов.                                                    :hello, wor:        */
    printf(":%-10s:\n",frase);          /* Печатает не менее 10 символов фразы с выравниванием по левому краю.                      :hello, world:      */
    printf(":%15s:\n",frase);           /* Печатает фразу в поле из 15 символов с выравниванием по правому краю.                    :   hello, world:   */
    printf(":%-15s:\n",frase);          /* Печатает фразу в поле из 15 символов с выравниванием по левому краю.                     :hello, world   :   */
    printf(":%15.10s:\n",frase);        /* Печатает первые 10 символов фразы в поле из 15 символов с выравниванием по правому краю. :     hello, wor:   */
    printf(":%-15.10s:\n",frase);       /* Печатает первые 10 символов фразы в поле из 15 символов с выравниванием по левому краю.  :hello, wor     :   */
    printf(":%.*s:\n",j,frase);         /* Печатает первые j (j=5) символов фразы.                                                  :hello:             */
    printf("EOF = %i",EOF);             /* Печатает значение переменной EOF, объявленной в stdio.h.                                 EOF = -1            */
    printf("\n\n");
    
    printf("Formating output of float and double\n");
    getchar();
    printf("f = %f\n",f);                 /* Печатает значение f. Адское округление.                                                                    1234.567871         */
    printf("d = %f\n",d);                 /* Печатает значение d. Точно до 10 десятичных цифр .                                                         1234.567890         */
    printf("d = %15f\n",d);               /* Печатает значение d. В поле из 15 символов с выравниванием по правому краю.                                    1234.567890     */
    printf("d = %-15f\n",d);              /* Печатает значение d. В поле из 15 символов с выравниванием по левому краю.                                 1234.567890         */
    printf("d = %15.3f\n",d);             /* Печатает значение d. В поле из 15 символов с тремя знаками после запятой с выравниванием по правому краю.         1234.568     */
    printf("d = %-15.3f\n",d);            /* Печатает значение d. В поле из 15 символов с тремя знаками после запятой с выравниванием по левому краю.   1234.568            */
    printf("d = %.3f\n",d);               /* Печатает значение d с тремя знаками после запятой.                                                         1234.568            */
    printf("d = %-.3f\n",d);              /* Печатает значение d с тремя знаками после запятой.                                                         1234.568            */

    printf("Output size of different types\n\n");                                       /* Распечатка размера различных типов.  */
    getchar();
    printf("Size of char type         = %i bytes \n", sizeof(char));                    /* Размер типа         char = 1 bytes.  */
    printf("Size of short type        = %i bytes \n", sizeof(short));                   /* Размер типа        short = 2 bytes.  */
    printf("Size of int type          = %i bytes \n", sizeof(int));                     /* Размер типа          int = 3 bytes.  */
    printf("Size of long long type    = %i bytes \n", sizeof(long long));               /* Размер типа    long long = 8 bytes.  */
    printf("Size of float type        = %i bytes \n", sizeof(float));                   /* Размер типа        float = 4 bytes.  */
    printf("Size of double type       = %i bytes \n", sizeof(double));                  /* Размер типа       double = 8 bytes.  */
    printf("Size of enum counter      = %i bytes \n", sizeof(e_v));                     /* Размер типа enum counter = 4 bytes.  */
    printf("Size of char* type        = %i bytes \n", sizeof(char*));                   /* Размер типа        char* = 4 bytes.  */
    printf("Size of i_arr             = %i bytes \n", sizeof(i_arr));                   /* Размер массива     i_arr = 12 bytes. */
    printf("Size of s_arr             = %i bytes \n", sizeof(s_arr));                   /* Размер массива     s_arr = 12 bytes. */
    printf("Size of c_string          = %i bytes \n", sizeof(c_string));                /* Размер массива  c_string = 9 bytes.  */
    printf("Size of bit_field type    = %i bytes \n", sizeof(b_f));                     /* Размер типа    bit_field = 4 bytes.  */
    printf("Size of complex_type type = %i bytes \n", sizeof(c_t));                     /* Размер типа complex_type = 8 bytes.  */
    printf("\n");

    printf("Output varibles value \n");                     /* Распечатка значений различных переменных.*/
    getchar();
    printf("c_var       = %c\n", c_var);                    /* Значение переменной типа char в виде символа.                                 A                          */
    printf("Code c_var  = %i\n", c_var);                    /* Значение переменной типа char в виде кода.                                    65                         */
    printf("s_var       = %i\n", s_var);                    /* Значение переменной типа short.                                               32767                      */
    printf("i_var       = %i\n", i_var);                    /* Значение переменной типа int.                                                 2147483647                 */
    printf("l_var       = %lli\n", l_var);                  /* Значение переменной типа long long.                                           9223372036854775807        */
    printf("f_var       = %e\n", f_var);                    /* Значение переменной типа float в экспоненциальном формате.                    3.402823466e38             */
    printf("d_var       = %e\n", d_var);                    /* Значение переменной типа double в экспоненциальном формате.                   1.7976931348623158e308     */
    printf("uc_var      = %c\n", uc_var);                   /* Значение переменной типа undigned char в виде символа.                        A                          */
    printf("Code uc_var = %u\n", uc_var);                   /* Значение переменной типа undigned char в виде кода.                           65                         */
    printf("us_var      = %u\n", us_var);                   /* Значение переменной типа undigned short.                                      65535                      */
    printf("ui_var      = %u\n", ui_var);                   /* Значение переменной типа undigned int.                                        4294967295                 */
    printf("ul_var      = %llu\n", ul_var);                 /* Значение переменной типа undigned long long.                                  18446744073709551615       */
    printf("e_v         = %i\n", e_v);                      /* Значение переменной типа enum counter.                                        0                          */
    if (e_v == e_v_2) printf("e_v_2       = %i\n", e_v_2);  /* Значение переменных e_v и e_v_2 равны, хотя они из разных перечислений.       0                          */
    printf("c_string    = %s\n", c_string);                 /* Значение массива c_string в виде строки.                                      abcdefgh                   */
    printf("*p_string   = %s\n", p_string);                 /* Значение массива c_string в виде строки через указатель *p_string.            abcdefgh                   */
    printf("p_string    = %i\n", p_string);                 /* Значение указателя p_string.                                                  4214864 (к примеру)        */
    printf("\n");
    
    printf("Increment varibles and output value \n");   /* Распечатка значений инкрементированных переменных (переполнение). */
    getchar();
    c_var = 127;
    uc_var = 255;
    c_var++;
    s_var++;
    i_var++;
    l_var++;
    f_var+= 1e32;
    d_var+= 1e292;
    uc_var++;
    us_var++;
    ui_var++;
    ul_var++;
    e_v++;

    printf("Code c_var  = %i\n", c_var);                /* Значение переменной типа char в виде кода.                   -128                    */
    printf("s_var       = %i\n", s_var);                /* Значение переменной типа short.                              -32768                  */
    printf("i_var       = %i\n", i_var);                /* Значение переменной типа int.                                -2147483648             */
    printf("l_var       = %lli\n", l_var);              /* Значение переменной типа long long.                          -9223372036854775808    */
    printf("f_var       = %e\n", f_var);                /* Значение переменной типа float в экспоненциальном формате.   1.#INF00e+000           */
    printf("d_var       = %e\n", d_var);                /* Значение переменной типа double в экспоненциальном формате.  1.#INF00e+000           */
    printf("Code uc_var = %u\n", uc_var);               /* Значение переменной типа undigned char в виде кода.          0                       */
    printf("us_var      = %u\n", us_var);               /* Значение переменной типа undigned short.                     0                       */
    printf("ui_var      = %u\n", ui_var);               /* Значение переменной типа undigned int.                       0                       */
    printf("ul_var      = %llu\n", ul_var);             /* Значение переменной типа undigned long long.                 0                       */
    printf("e_v         = %i\n", e_v);                  /* Значение переменной типа enum counter.                       1                       */
    printf("\n");

    b_f.b1 = b_f.b2 = b_f.b3 = 0;                       /* Инициализация битового поля b_f. */

    printf("b_f.b1 b_f.b2 b_f.b3\n");                   /* Печать в столбик значений битвых полей при циклической инкрементации. */
    for (i = 0; i < 9; i++)
        printf("   %i      %i      %i\n", b_f.b1++, b_f.b2++, b_f.b3++);    /*  b_f.b1  b_f.b2  b_f.b3  */
                                                                            /*    0        0       0    */
                                                                            /*    1        1       1    */
                                                                            /*    0        2       2    */
                                                                            /*    1        3       3    */
                                                                            /*    0        0       4    */
                                                                            /*    1        1       5    */
                                                                            /*    0        2       6    */
                                                                            /*    1        3       7    */
                                                                            /*    0        0       0    */
    printf("\n");
    
    c_t.c_v = 'a';                                      /* Инициализация полей структуры c_t. */
    printf("c_t.c_v     = %c\n", c_t.c_v);              /* Значение поля c_v структуры c_t.                                 a       */
    c_t.i_v = 13;
    printf("c_t.i_v     = %i\n", c_t.i_v);              /* Значение поля i_v структуры c_t.                                 13      */
    c_t.f_v = 1.1e2;
    printf("c_t.f_v     = %f\n", c_t.f_v);              /* Значение поля f_v структуры c_t.                                 110     */
    printf("c_t.c_v     = %c\n", c_t.c_v);              /* Значение поля c_v структуры c_t затираестя другими полями.               */
    printf("\n");

    return;
}

void lesson_2()                                             /* Второй урок. Математическое и логические операции. */
{
int faren = 10;
   
    printf("%s%i\n", "Slogenie              10+3 = ", 10+3);  /* 13 */
    printf("%s%i\n", "Vichitanie            10-3 = ", 10-3);  /* 7  */
    printf("%s%i\n", "Umnogenie             10*3 = ", 10*3);  /* 30 */
    printf("%s%i\n", "Delenie               10/3 = ", 10/3);  /* 3  */
    printf("%s%i\n", "Ostatok ot deleniy    10%3 = ", 10%3);  /* 1  */
    printf("%s%i\n", "Logicheskoe -i-       2&&7 = ", 2&&7);  /* 1  */
    printf("%s%i\n", "Logicheskoe -ili-     2||7 = ", 2||7);  /* 1  */
    printf("%s%i\n", "Logicheskoe -ne-        !2 = ", !2);    /* 0  */
    printf("%s%i\n", "Pobitovoe   -i-        2&7 = ", 2&7);   /* 2  */
    printf("%s%i\n", "Pobitovoe   -ili-      2|7 = ", 2|7);   /* 7  */
    printf("%s%i\n", "Pobitovoe   -ne-ili-   2^7 = ", 2^7);   /* 5  */
    printf("%s%i\n", "Sdvig vlevo na 1 bit  7<<1 = ", 7<<1);  /* 14 */
    printf("%s%i\n", "Sdvig vpravo na 1 bit 7>>1 = ", 7>>1);  /* 3  */
    printf("%s%i\n", "Dopolnenie do -1        ~7 = ", ~7);    /* -8 */
                                    /*                                        Печать    Значение    */
    printf("%i\n", faren);          /* Печать                                   10      faren=10    */
    printf("%i\n", faren++);        /* Печать faren=10, потом инкрементация     10      faren=11    */
    printf("%i\n", faren);          /* Печать                                   11      faren=11    */
    printf("%i\n", ++faren);        /* Инкрементация faren=12, потом печать     12      faren=12    */
    printf("%i\n", faren);          /* Печать                                   12      faren=12    */
    printf("%i\n", faren+1);        /* Печать 13 без инкрементации              13      faren=12    */
    printf("%i\n", faren);          /* Печать                                   12      faren=12    */
    printf("\n");
    
return;
}

void lesson_3()                                                 /* Работа с циклами for, do, wile и конструкциями if else. */
{
int faren;                                                      /* Значение температуры по ‘фаренгейту. */
float celsium;                                                  /* Значение температуры по цельсию. */

    printf("\n");
    printf("for\n");                                            /* Использование цикла for. */
    for (faren = LOWER; faren <= UPPER; faren+= STEP)
    {
     celsium = 5.0 / 9.0 * (faren - 32.0);
     printf("%4.1d F = %4.1f C\n", faren, celsium);
    }
    printf("\n");    

    printf("do\n");                                                /* Использование цикла do. */
    faren = LOWER;
    do
    {
     celsium = 5.0 / 9.0 * (faren - 32.0);
     printf("%4.1d F = %4.1f C\n", faren, celsium);
     faren = faren + STEP;
    }
    while (faren <= UPPER);
    printf("\n");

    printf("while\n");                                          /* Использование цикла while. */
    faren = LOWER;
    while (faren <= UPPER)                                      /* Аналогично записи for (;faren<=UPPER;). */ 
    {
     celsium = 5.0 / 9.0 * (faren - 32.0);
     printf("%4.1d F = %4.1f C\n", faren, celsium);
     faren = faren + STEP;
    }
    printf("\n");
    
int a = 1;
int b = 2;
int c = 3;
int d = 4;
int e = 0;

    if (a) printf("a");             /* Печатает a. */
        else printf("no a");

    if (!a) printf("no a");         /* Печатает a. */
        else printf("a");

    if (a)                          /* Печатает b. */
        if (b) printf("b");
            else printf("no b");
        else printf("no a");

    if (a)                          /* Печатает b. */
        if (!b) printf("no b");
            else printf("b");
        else printf("no a");

    if (!a)                         /* Печатает a. */
        if (!b) printf("no b");
            else printf("b");
        else printf("a");

   return;
}

int *ff(void* arg)                        /* ff - функция, аргумент которой - указатель (на char), а результат - указатель на int. */
{
int i, j;
char *gg, *cc;

    i = 0;
    j =-1;
    do
    {
        gg = cmonth[i];                   /* gg указывает на элемент названия месяца. */
        cc = arg;                         /* сс указывает на аргумент. */
        if (*cc == *gg)                   /* Сравнение первых символов аргумента и названия месяца. */
            if (*++cc == *++gg)           /* Сравнение вторвых символов аргумента и названия месяца. */
                if (*++cc == *++gg)       /* Сравнение третьих символов аргумента и названия месяца. */
                    j = i;                /* Если три элемента совпадают, определить номер месяца. */
        i++;                              /* Иначе анализировать следующий элемент. */
    }
    while (i < 13 && j == -1);            /* Пока индекс массива имён месяца не превысил 12 и не определён индекс массива номеров месяца. */
    if (j == -1) j = 0;                   /* Если месяц не найден, то номер указателя приравнять 0 (nmonth[0] = NULL). */
    return nmonth[j];                     /* Возвращает указатель на номер месяца. */
}

void lesson_4()                                             /* Работа с указателями. */
{
int i;
char arc1[] = "13579";                      /* Объявление массива символов arc1[] и его инициализация. */
char *arc2 = "13579";                       /* Объявление указателя arc2 символ и его инициализация на безымянную строку. */
char *arc3;                                 /* Объявление указателя arc3 символ. */

    printf("\n");
    for (i = 0; i < 5; i++) printf("arc1[%1.1i%s%c\n",i,"]=", arc1[i]);     /* Печать значений массива символов arc1[] (13579.) */
    
    printf("\n");
    arc3 = &arc1[2];                        /* Указатель arc3 содержит адрес второго элемента массива символов arc1[] (указывает на 5). */
    printf("arc = %i\n", arc3 - &arc1[0]);  /* Печать значения разности адресов arc3 и &arc1[0]. */
    printf("*arc   = %c\n", *arc3);         /* Печать значения по указателю arc3 (5). */
    printf("*arc++ = %c\n", *arc3++);       /* Сначала берётся значение из памяти по указателю, */
    printf("*arc   = %c\n", *arc3);         /* потом изменяется указатель. */
    
    printf("\n");
    arc3 = &arc1[2];
    printf("arc = %i\n", arc3 - &arc1[0]);    
    printf("*arc   = %c\n", *arc3);
    printf("++*arc = %c\n", ++*arc3);        /* Изменяется значение в памяти по указателю. */
    printf("*arc   = %c\n", *arc3);
    
    printf("\n");
    arc3 = &arc1[2];
    printf("arc = %i\n", arc3 - &arc1[0]);    
    printf("*arc   = %c\n", *arc3);
    printf("*++arc = %c\n", *++arc3);        /* Сначала изменяется указатель, */
    printf("*arc   = %c\n", *arc3);          /* Потом берётся значение из памяти по указателю. */
    
/*  printf("\n");
    printf("*arc2 = %c\n", *arc2);
    *arc2 = 0;                                   Попытка изменить константу прерывает программу. 
    printf("*arc2 = %c\n", *arc2);
*/
    /* Вычисление середины строки через указатели на строку */
char str[] = "0123456789";                      /* Массив из 9-и символьных элементов. */
char *a, *b;                                    /* Указатели на символы. */

    a = b = str;                                /* Указатели на символы указывают на начало массива str. */
    b+= 9 * sizeof(char);                       /* b указывает на последний символ массива str. */
    printf("Beg of str = %c\n",*a);             /* Вывод первого символа массива str. */
    printf("End of str = %c\n",*b);             /* Вывод последнего символа массива str. */
    b = a + (b - a) / 2;                        /* b указывает на средний символ массива str. Использовать запись (a+b)/2 - нельзя по синтаксису */
    printf("Mid of str = %c\n",*b);             /* Вывод среднего символа массива str. */


int arc5[] = {0,1,2,3,4,5,6,7,8,9};                                         /* Массив целых. */
int *arc4[10];                                                              /* Массив указателей на целые. */
int *m1, m2;                                                                /* Так определяются несколько указателей. */
int  **aa;                                                                  /* Указатель на указатель на целые. */

char *bb[] = {"abc", "de", "fg"};                                           /* Массив указателей на строки символов. */
char *c;                                                                    /* Указатель на символ. */

    for (i = 0; i < 10; i++) arc4[i] = &arc5[i];                            /* Инициализация массива указателей на целые. */
    printf("\n");                                                           /* Элементы arc4 указывают на элементы arc5. */
    
    for (i = 0; i < 10; i++) printf("   arc5[%i%s%i%s",i,"]=",arc5[i]," "); /* Печать начений массива целых. */
    printf("\n");    
    
    for (i = 0; i < 10; i++) printf("  *arc4[%i%s%i%s",i,"]=",*arc4[i]," "); /* Печать массива целых по указателям из массива указателей. */
    printf("\n");
    
    aa = arc4;                                                               /* aa указывает на начало массива с указателями arc4. */
    for (i = 0; i < 10; i++) printf(" **aa++[%i%s%i%s",i,"]=", **aa++," ");  /* Печать массива целых по указателям из массива указателей. */
    printf("\n");

    for (i = 0; i < 10; i++) printf("   arc5[%i%s%i%s",i,"]=",arc5[i]," ");  /* Печать начений массива целых arc5. */
    printf("\n");    

    c = bb[0];                                                               /* c указывает на первый символ строки "abc". */
    printf("   c = bb[0]\n");
    printf("  *c = %c\n", *c);
    printf("*++c = %c\n", *++c);                                            /* c указывает на второй символ строки "abc". */
    printf("*++c = %c\n", *++c);                                            /* c указывает на третий символ строки "abc". */
    printf("*++c = %c\n", *++c);                                            /* c указывает на четвёртый символ строки "abc", который пустой (конец строки). */
    printf("*++c = %c\n", *++c);                                            /* c указывает на следующий символ после строки "abc", который. */
                                                                            /*   случайно является первым символом строки "de". */
                                                                            
    printf("*++c = %c\n", *++c);                                            /* c указывает на второй символ строки "de". */
    printf("*++c = %c\n", *++c);                                            /* c указывает на третий символ строки "de", который пустой (конец строки). */

    c = bb[1];                                                              /* c указывает на первый символ строки "de". */
    printf("   c = bb[1]\n");
    printf("  *c = %c\n", *c);
    printf("*++c = %c\n", *++c);                                            /* c указывает на второй символ строки "de". */
    printf("\n");
    
    printf("*bb[0] = %c\n", *bb[0]);                                        /* Печать первого символа строки "de". */
/*    printf("*bb[0] = %s\n", *bb[0]);                                      /* Не правильная команда, так как *bbb[0] - char. */
/*    printf("bb[0] = %c\n", bb[0]);                                        /* Не правильная команда, так как bb[0] - & string. */
    printf("\n");
    
    printf(" bb[0] = %s\n", bb[0]);                                          /* Печать строки "abc". */
    printf("\n");

    for (i = 0; i < 3; i++) printf(" bb[%i%s%s\n", i, "] = ", bb[i]);        /* Печать всех элементов массива. */
    printf("\n");

    for (i = 0; i < 3; i++) printf("*bb[%i%s%c\n", i, "] = ", *bb[i]);       /* Печать первых элементов массива. */
    printf("\n");

    for (i = 0; i < 13; i++)                   /* Инициализация массива номеров и массива ссылок на номера. */
    {
        m[i] = i;
        nmonth[i] = &m[i];
    }
    
    b = cmonth[5];                             /* b указывает на "june" */
    printf("%c\n",*b);
    ab = ff(b);                                /* a - ссылка на m[5]=5 */
    printf("%i\n",*ab);

    return; 
}

void change(char *c1, char *c2)                        /* Функция перестановки символов по указателям. */
{
char c3;
    c3 = *c1;
    *c1 = *c2;
    *c2 = c3;
}

char *maxi(char *c1, char *c2)                      /* Функция возвращает указатель на больший символ. */
{
static char *c3;                                    /* c3 - статический указатель, который инициализируется лишь первый раз и остаётся после выхода из функции. */

    if (*c1 > *c2)  c3 = c1; else c3 = c1;
    return c3;
}

void lesson_5()                                     /* Работа с указателями на функции. */
{
char *(*ptf)(char *, char *);                       /* *ptf - указатель на функцию, возвращающую указатель на char. */
void *(*ptfu)(void *, void *);                      /* *ptfu - универсальный указатель на функцию, возвращающую универсальный указатель. */
char arcch[] = "35";                                /* символы '3' и '5'. */
char *c1 = &arcch[0], *c2 = &arcch[1], *c3;         /* c1 указывает на '3', c2 указывает на '5'. */

    printf("*c1 = %c\n", *c1);
    printf("*c2 = %c\n", *c2);
    change(c1, c2);                                 /* поменять значения c1 и c2 (теперь c1 указывает на '5', c2 указывает на '3'). */
    printf("*c1 = %c\n", *c1);
    printf("*c2 = %c\n", *c2);
    ptf = maxi;                                     /* Теперь ptr указывает на функцию maxi. */
    c3 = (*ptf)(c1, c2);                            /* Вызов функции maxi через указатель на неё ptr. */
    printf("MAX = *c3 = %c\n", *c3);                /* Печать максимального символа через указатель. */
    c3 = 0;                                         /* Сброс c3. */
    ptfu = ptf;
    c3 = (*ptfu)(c1, c2);                           /* Вызов функции maxi через универсальный указатель на неё ptrfu. */
    printf("MAX = *c3 = %c\n", *c3);                /* Печать максимального символа через указатель. */
    return;
}

typedef struct point                /* point (точка) - структура из двух целочисленных полей (x:y). */
{
    int x, y;
} t_point;                          /* тип t_point. */

typedef struct line                 /* line (линия) - структура из двух структур point. */
{
    t_point ptr1, ptr2;
} t_line;                           /* тип t_line. */

typedef struct rectangle            /* rectangle (прямоугольник) - структура из структуры line. */
{
    t_line rect;
} t_rectangle;                      /* тип t_rectangle. */

typedef struct example              /* example - структура-пример. */
{
    int n;
    char *c;
} t_example;                        /* тип t_example. */

typedef struct key                  /* example - структура-пример. */
{
    char *word;
    int count;
} t_key;                            /* тип t_example. */

t_point makepoint(int xx, int yy)   /* Функция makepoint возвращает структуру point. */
{
t_point temp;
    temp.x = xx;
    temp.y = yy;
    return temp;
}

void reclnorm(t_rectangle *r)        /* Функция нормирования прямоугольника. */
{
int minx, miny, maxx, maxy;
    minx=(r->rect.ptr1.x < r->rect.ptr2.x) ? r->rect.ptr1.x : r->rect.ptr2.x;
    maxx=(r->rect.ptr1.x > r->rect.ptr2.x) ? r->rect.ptr1.x : r->rect.ptr2.x;
    miny=(r->rect.ptr1.y < r->rect.ptr2.y) ? r->rect.ptr1.y : r->rect.ptr2.y;
    maxy=(r->rect.ptr1.y > r->rect.ptr2.y) ? r->rect.ptr1.y : r->rect.ptr2.y;
    r->rect.ptr1.x = minx;
    r->rect.ptr2.x = maxx;
    r->rect.ptr1.y = miny;
    r->rect.ptr2.y = maxy;
}

int ptinrec(t_rectangle *r, t_point *p)        /* Функция возвращает 1, если точка принадлежит прямоугольнику, иначе - 0. */
{
    return p->x > r->rect.ptr1.x && p->x < r->rect.ptr2.x && p->y > r->rect.ptr1.y && p->y < r->rect.ptr2.y;
}

void lesson_6()                                     /* Работа со структурами. */
{
t_point ptr1, ptr2, pt3;           /* ptr1, ptr2, pt3 - переменные типа структура point. */
t_rectangle ptr4;                  /* ptr4 - переменная типа структура rectangle. */
t_point *ptp;                      /* *ptp - указатель на структуру point. */
t_rectangle *ptr;                  /* *ptr - указатель на структуру rectangle. */

t_example ex1;                     /* ex1 - структура из целого и указателя на char. */
t_example *pexx;                   /* *pexx  - указатель на структура из целого и указателя на char. */

char str[] = "02468AcE";           /* str - строка символов. */

t_key keytab[] = {"abc", 0, "def", 0};  /* keytab[] - массив структур. */

int r;
            
    ptr1 = makepoint(10,10);                                            /* Инициализация полей переменной ptr1. */
    ptp = &ptr2;
    *ptp = makepoint(1,1);                                              /* Инициализация полей переменной ptr2 через указатель. */
    printf(" ptr1 = %i%s%i\n", ptr1.x, " : ", ptr1.y);                  /* Печать полей переменной ptr1. */
    printf(" ptr2 = %i%s%i\n", ptr2.x, " : ", ptr2.y);                  /* Печать полей переменной ptr2. */
    
/*    ptr1=makepoint(12,12);                                             /* Инициализация переменной ptr1 с помощью функции makepoint. */
/*    printf(" ptr1 = %i%s%i\n", ptr1.x, " : ", ptr1.y);                 /* Печать полей переменной ptr1. */
    
    ptp = &ptr1;                                                         /* ptp = адрес ptr1. */
    printf(" ptp=&ptr1\n");
    printf("*ptp = %i%s%i\n", (*ptp).x, " : ", (*ptp).y);                /* Печать переменной по указателю *ptp. */
    printf("*ptp = %i%s%i\n", ptp->x, " : ", ptp->y);                    /* Печать переменной по указателю *ptp (другой синтаксис). */    

    ptp = &ptr2;                                                         /* ptp = адрес ptr2. */
    printf(" ptp=&ptr2\n");
    printf("*ptp = %i%s%i\n", (*ptp).x, " : ", (*ptp).y);                /* Печать переменной по указателю *ptp. */
    printf("*ptp = %i%s%i\n", ptp->x, " : ", ptp->y);                    /* Печать переменной по указателю *ptp (другой синтаксис). */
    
    ptr4.rect.ptr1 = ptr1;                                               /* Инициализация прямоугольника. */
    ptr4.rect.ptr2 = ptr2;
    ptr = &ptr4;
    reclnorm(ptr);                                                        /* Нормирование прямоугольника. */
    pt3 = makepoint(5,5);                                                 /* Инициализация полей переменной pt3. */
    ptp = &pt3;                                                           /* ptp = адрес pt3. */
    printf("*ptp = %i%s%i", ptp->x, " : ", ptp->y);                       /* Печать переменной по указателю *ptp=pt3. */
    r = ptinrec(ptr,ptp);                                                 /* Определение принадлежнисти точки прямоугольнику. */
    if (r) printf(" YES\n"); else printf(" NO\n");                        /* Если принадлежит, печатать "YES", иначе - "NO". */
    pt3 = makepoint(15,5);                                                /* Инициализация полей переменной pt3. */
    printf("*ptp = %i%s%i", ptp->x, " : ", ptp->y);                       /* Печать переменной по указателю *ptp=pt3. */
    r = ptinrec(ptr,ptp);                                                 /* Определение принадлежнисти точки прямоугольнику. */
    if (r) printf(" YES\n"); else printf(" NO\n");                        /* Если принадлежит, печатать "YES", иначе - "NO". */
    
    printf("\n");
    pexx = &ex1;                                                        /* pexx указывает на ex1. */
    ex1.n = 5;                                                          /* ex1.x = 5. */
    ex1.c = str;                                                        /* ex1.c - указыывает на SrT[0]. */
    printf("*pexx->c = %c\n", *pexx->c);                                /* Печать поля ex1.c (указывает на '0'). */
    printf("*pexx->c++ = %c\n", *pexx->c++);                            /* Печать поля ex1.c и увеличение указателя c. */
    printf("*pexx->c = %c\n", *pexx->c);                                /* Печать поля ex1.c (теперь указывает на '2'). */
    
    printf("\n");
    ++pexx->c;                                                           /* Увеличит С на 1 (теперь ex1.c указывает на str[2] = '4'). */
    printf("++pexx->c\n");
    printf("*pexx->c = %c\n", *pexx->c);
    printf("str[0] = %c\n", str[0]);
    printf("str[1] = %c\n", str[1]);
    printf("str[2] = %c\n", str[2]);
    
    printf("\n");
    (*pexx->c)++;                                                        /* Увеличит *С на 1 (теперь ex1.c указывает на str[2] = '5', т.е. изменили str[2]). */
    printf("(*pexx->c)++\n");
    printf("*pexx->c = %c\n", *pexx->c);
    printf("str[0] = %c\n", str[0]);
    printf("str[1] = %c\n", str[1]);
    printf("str[2] = %c\n", str[2]);
    
    printf("\n");                                                        /* Печать элементов массива структур keytab. */
    printf("keytab[0].word = %c\n", *keytab[0].word);
    printf("keytab[0].count = %i\n", keytab[0].count);
    printf("keytab[0].word++ = %c\n", *keytab[0].word++);
    printf("keytab[0].word = %c\n", *keytab[0].word);
    
    printf("\n");
    r = sizeof(keytab)/sizeof(t_key);                                    /* Количество элементов в массиве keytab = (размер массива keytab)/(размер типа t_key). */
    printf("keytab have %i%s\n", r, " elements");    

    return;
}

void lesson_7()                                     /* Работа с файлами. */
{
FILE *fp;                                                   /* fp - указатель на поток (открытый файл). */
char *ptf = "aaa.txt";                                      /* ptf - указатель на имя файла (aaa.txt). */
char *pta;                                                  /* pta - указатель на аргумент. */
char ch, arg;                                               /* arg - аргумент. */
char string[] = "Hello, word!";                             /* Строка символов. */

    arg = 'w';                                              /* Аргумент = "запись". */
    pta = &arg;                                             /* Инициализация указателя на аргумент. */
    fp = NULL;                                              /* Обнуление указателя на поток. */
    printf("fp = %i\n",fp);                                 /* Контроль значения указателя на поток. */
    fp = fopen(ptf,pta);                                    /* Открытие (создание) файла (aaa.txt) на запись и инициализация указателя на поток (открытый файл). */
    printf("fp = %i\n",fp);                                 /* Контроль значения указателя на поток. */
    fprintf(fp, "%s", string);                              /* Запись в файл строки. */
    fprintf(fp, "\n%i", 32);                                /* Запись в файл числа 32 (в символьном формате). */
    fclose(fp);                                             /* Закрытие файла (aaa.txt). */
    freopen(ptf,"a",stdout);                                /* Перенаправить поток вывода в файл (aaa.txt). */
    printf("\n%i",12);                                      /* Напечатать \n, 12 в поток вывода. */
    fclose(fp);                                             /* Закрытие файла (aaa.txt). */
    freopen("CON","w",stdout);                              /* Перенаправить поток вавода обратно в консоль (на экран). */
    printf("\n output in consol %i\n",12);                  /* Проверка вывода в консоль (на экран). */
    arg = 'r';                                              /* Аргумент = "чтение". */
    fp = fopen(ptf,pta);                                    /* Открытие файла (aaa.txt) на чтение и инициализация указателя на поток (открытый файл). */
    printf("fp = %i\n",fp);                                 /* Контроль значения указателя на поток. */
    printf("Output from file\n");
    for (; fscanf(fp,"%c", &ch)!=EOF; ) printf("%c", ch);   /* Печать на экран содержимого файла (aaa.txt). */
    fclose(fp);                                             /* Закрытие файла (aaa.txt). */
    printf("\n");
    printf("Command DIR execution\n");
    system("dir");                                          /* Выполнение системой команды dir. */
    
    return;   
}

double strnum()                  /* str_num Перевод символьного числа в числовое. */
{
int i, j;                        /* Переменные цикла. */
int c;                           /* Символьная переменная c=ENTER при инициализации. */
double k, e;                     /* k - число (по умолчанию =0), E - вспомогателная переменная. */
int sign;                        /* sign - знак числа. */

L1:    k = i = 0;                /* k по умолчанию = 0. */
    j = 10;

    do                           /* Пропускает пробелы, табуляции и ENTER. */
        c = getchar();
    while (c == ' ' || c == '\t' || c == '\n');
                                    
    sign=(c == '-') ? -1 : 1;                        /* Определение знака. */
    c = (c == '+' || c == '-') ? getchar() : c;      /* Если в буффере + или -, то считать следующий символ. */
    
    while (c >= '0' && c <= '9')                     /* Формирование целой части k. */
    {
        k = k*10 + c - '0';                          /* При инициализации k=0. */
        c = getchar();
    }
    
    if (c == '.')                                    /* Формирование дробной части k. */
        while ((c=getchar()) >= '0'&&c<='9')
        {
            k = k+1.0/j*(c-'0');
            j*= 10;                                  /* При инициализации j=10. */
        }
    
    if (c == 'e' || c == 'E')                        /* Формирование экспоненциальной части k. */
    {
        c = getchar();                               /* Читаем следующий символ. */

        e = (c == '-') ? 0.1 : 10;                   /* реакция на + -. */
        c = (c == '+' || c == '-') ? getchar() : c;  /* Если в буффере + или -, то считать следующий символ. */
        
        while (c >= '0' && c <= '9')
        {
            i = i * 10 + c - '0';                    /* При инициализации i=0. */
            c = getchar();
        }

        for (j = i; j >= 1; j--)
          k*= e;                                     /* Умножение k на 10 в степени. */
    }

    for (i = 0; c == ' ' || c == '\t'; i++)
      c = getchar();                                 /* Пропускает пробелы и табуляции после цифр. */

    if (c == '\n')
      return(k * sign);                              /* Если введённый символ ENTER, то вернуть значение k со знаком. */
  
    printf("Unknoun symbol");                        /* иначе печатать "неизвесный символ". */
    goto L1;                                         /* и выполнять ввод заново. */
}

void lesson_8()                                      /* Формирует число из строки. */
{
double M;
    M=strnum();
    printf("\n%s%f%s%e\n", "M = ", M, " = ", M);
    
    return;
}

typedef struct node                         /* Структура узла. */
{
    char *word;
    int count;
    struct node *left;
    struct node *right;
} knot;

void getword(char *ptstring, int len)       /* Функция заполняет массив по указателю *ptstring очередным словом */
                                            /* из входного потока. Если длина слова превышает максимум len, */
                                            /* или символ не принадлежит ASCii, то */
                                            /* выдаётся сообщение об ошибке и функция останавливается. */
                                            /* Если прочитаны все символы строки, то последний символ слова */
                                            /* равен 0, иначе последний символ слова равен ' '. */
{
char *ptc;                                  /* Вспомогательная переменная. */
char vchar2;                                /* Вспомогательная переменная. */
int i = 0;                                  /* Счётчик символов в слове. */

    ptc = ptstring;                                                /* Запомнить адрес начала выходного массива. */
    vchar2 = getchar();                                            /* Читаем первый символ. */
    while (vchar2 == ' ' || vchar2 == '\t') vchar2 = getchar();    /* Пропускаем пробелы и табуляции. */
    while (vchar2 > 32 && vchar2 < 127 && i < len-1)               /* Пока читаются буквы ASCii и счётчик символов не переполнен. */
    {
        *ptstring = vchar2;                                        /* Заполняем массив прочитаной буквой. */
        ptstring++;                                                /* Смещаем указатель на следующий элемент массива. */
        i++;                                                       /* Увеличиваем счётчик символов. */
        vchar2 = getchar();                                        /* Считываем следующий символ. */
    }
    if ((vchar2 < 32 || vchar2 > 126) && vchar2 != '\t' && vchar2 != '\n')     /* Если символ не ASCii, не ' ', не '\t', и не '\n', то */
    {
        vchar2 = '\n';                                             /* считаем, что прочитали последний символ; */
        ptstring = ptc;                                            /* смещаем указатель на начальный элемент массива. */
        printf("\n");
        printf("Unknoun symbol\n");                                /* Вывод сообщения об ошибке. */
        i = 0;                                                     /* Сброс счётчика символов. */
    }
    if (i == len-1 && vchar2 != '\n' && vchar2 != ' '&&vchar2 != '\t')       /* Если счётчик символов в слове закончился и следующий символ не разделительный, то*/
    {
        printf("\n");
        printf("Very long word in frase\n");                       /* вывод сообщения об ошибке. */
        ptstring = ptc;                                            /* Смещаем указатель на начальный элемент массива. */
        vchar2 = '\n';                                             /* Меняем последний прочитанный символ на разделительный. */
    }
    if (vchar2 == '\n') vchar2 = 0; else vchar2 = ' ';             /* Если разделительный символ '\n', то заменить его на 0 иначе на ' '. */
    *ptstring = vchar2;                                            /* Завершить слово. */
    return;
}

int strcmp(char *ptone, char *pttwo)                               /* Функция сравнения строк. Возвращает 0, если строки равны, 1 если первая строка больше второй и -1, если меньше. */
{
int i = 0;                                                         /* Априорно слова равны. */

    for (; *ptone == *pttwo && *ptone > 32 && *ptone < 127; ptone++) pttwo++;          /* Пока символы равны, двигаемся по строкам. */
    if (*ptone > 32 && *ptone < 127 && *pttwo > 32 && *pttwo < 127)                    /* если в обоих строках символы, то */
        if (*ptone > *pttwo) i++; else i--;                                            /* если  в первой строке символ больше, чем во сторой, i=1 иначе i=-1, */
    else                                                                               /* иначе */
        if (*ptone > 32 && *ptone < 127 && (*pttwo < 33 || *pttwo > 126)) i++;         /* если в второй строке разделительный символ, а в первой  - нет, то i=1, */
        else if (*pttwo > 32 && *pttwo < 127 && (*ptone < 33 || *ptone > 126)) i--;    /* иначе если в первой строке разделительный символ, а во второй- нет, то i=-1 */
    return i;                                                                          /* (если в обоих строках символы разделительные, но разные, то i=0 априорно). */
}

knot *addtree(knot *pt, char *pw)              /* Функция создаёт и выращивает дерево по указателю pt из слов по указателю pw. */
{
int i;

    if (pt == NULL)                            /* Если узла ещё нет, то */
    {
        pt=malloc(sizeof(knot));               /* выделить память для узла дерева. */
        if (pt != NULL);                       /* Если память выделена, то */
        {
            pt->word = pw;                     /* инициализация полей узла. */
            pt->count = 1;
            pt->left = pt->right = NULL;
        }
    } else                                     /* Если дерево уже есть, то */
        switch (i = strcmp(pw, pt->word))      /* сравнить слово аргумента со словом в узле. */
        {
            case 0    : pt->count++; break;                         /* Если равны, то слово уже встречалось. */
            case 1    : pt->right = addtree(pt->right, pw); break;  /* Если больше, перейти в правый узел. */
            default : pt->left = addtree(pt->left, pw); break;      /* Если меньше, перейти в левый узел. */
        }
    return pt;                                                      /* Вернуть указатель на дерево. */
}

knot *deltree(knot *pt)
{
    if ((pt->left) != NULL) pt->left=deltree(pt->left);             /* Если левый узел не пуст, удалить его. */
    if ((pt->right) != NULL) pt->left=deltree(pt->right);           /* Если правый узел не пуст, удалить его. */
    printf("deleted ");                                             /* Напечатать слово, узел которого удаляется. */
    for (; *pt->word != ' ' && *pt->word != 0; pt->word++) printf("%c", *pt->word);
    printf("\n");
    free(pt);                                                       /* Освободить память, выделенную для этого узла. */
    return    NULL;                                                 /* Вернуть пустой адрес этого узла. */
}

void treeprint(knot *pt)
{
char *pw;
    if (pt != NULL)                                                     /* Если узел не пуст, то */
    {
        treeprint(pt->left);                                            /* напечатать левый узел, затем */
        printf("%4d\t", pt->count);                                     /* напечатать количество повторений слова. */
        for (pw = pt->word; *pw != ' ' && *pw != 0; pw++) printf("%c", *pw);    /* Напечатать слово. */
        printf("\n");
        treeprint(pt->right);                                           /* Напечатать правый узел. */
    }
    return;
}

void lesson_9()                                     /* Формирование и удаление бинарного дерева. */
{                                                   /* Строится бинарное дерево из слов и печатает их в лексиграфическом порядке с указанием количества повторений. */
                                                    /* Тестовая фраза: now is the time for all good men to come to the aid of their party. */
                                                    /* В конце дерево ликвидируется с контролем удаления узлов. */
                                                    
char string[MAXSTRING];            /* Массив строки (куда будут помещаться слова). */
char *pts1;                        /* pts1 - указатель на массив string. */
char *ptw1;                        /* Вспомогательные переменные. */
knot *pttree;                      /* Указатель на дерево. */
int i;                             /* Вспомогательные переменные циклов. */

    pttree = NULL;
    i = 0;
    pts1 = &string[0];
    printf("\n");
    printf("input frase\n");
    do
    {
        if ((&string[0] + MAXSTRING * sizeof(char)) < (pts1 + MAXWORD * sizeof(char)))    /* Если места для следующего слова может не хватить, то */
        {
            printf("My be few memory fo next word");            /* вывести сообщение об ошибке */
            break;                                              /* и прервать цикл. */
        }
        getword(pts1, MAXWORD);                                 /* Получаем очередное слово и записываем его в массив string. */
        if (*pts1 == 0) break;                                  /* Если слово пустое, прервать цикл. */
        pttree = addtree(pttree,pts1);                          /* Добавить слово в дерево. */
        if (pttree == NULL)                                     /* Если указатель пуст, то */
        {
            printf("No memori in computer\n");                  /* вывести сообщение об ошибке */
            break;                                              /* и прервать цикл. */
        }
        for (; *pts1 != ' ' && *pts1 != 0; pts1++);             /* Передвигаем указатель до конца слова на пустое место, */
        ptw1 = pts1;                                            /* запоминаем адрес последнего символа последнего слова, */
        pts1++;                                                 /* и далее на пустое место */
        *pts1 = 0;                                              /* Инициализируем первую свободную ячейку как конец слова. */
    }
    while (*ptw1 != 0);                                         /* Если последний символ последнего слова 0, завершаем обработку входного потока. */
    printf("\n");
    for (i = 0; string[i] != 0; i++) printf("%c", string[i]);   /* Вывод фразы из массива string. */
    printf("\n\n");
    treeprint(pttree);                                          /* Печать слов в лексиграфическом порядке с количеством повторений. */
    printf("\n");
    pttree = deltree(pttree);                                   /* Освобождение памяти. */
    
    return;
}

#pragma startup prestart              /* Перед запуском программы запускает функцию prestart() во вторую очередь. */
#pragma startup prestart_finish       /* Перед запуском программы запускает функцию prestart_finish() в первую очередь. */

int main(int var_i1, char *var_c1[])                        /* Объявляем главную функцию. С неё начнётся выполнение программы. Имя main зарезервировано. */
{                                                           /* main имеет тип int и возвращает системе 0 при успешном завершении выполнения, или не 0 при возникновении ошибки. */
                                                            /* Аргументами main являются целое число (здесь var_i1), равное количеству аргументов в командной строке и */
                                                            /* массив указателей на строки аргументов (здесь *var_c1[]). */
                                                            /* *var_c1[0] указывает на имя программы. */
                                                            /* При отсутствии аргументов var_i1 = 1 */
                                                            
                                                            /* При запуске программы следует указать аргумент от 1 до 9 : "Ctextbook.exe 1". */
                                                            
/* int main() - можно писать, если при запуске не предполагается передача аргументов через командную строку. */                                                            
                                                            
    /* Объявление локальных переменных */
int i = 0, j = 0;                                           /* i, j - вспомогательные локальные переменные. */
                                                            /* В данной процедуре они затеняют переменные i, j объявленные выше (строка 74) как глобальные. */
    printf("\n");
    printf("Quantity of arguments = %i\n\n", var_i1);       /* Вывод информации о количестве аргументов, переданных в командной строке. */
    printf("\n");
    printf("Hello, World!\n\n");

    switch (*var_c1[1])                                     /* Анализировать переменную по указателю *var_c1[1]. */
    {
        case '1' :                                          /* Если *var_c1[1] == '1' , то */
            lesson_1();                                     /* обратиться к функции lesson_1 и */
            break;                                          /* прервать анализ переменной *var_c1[1]. */
        case '2' :                                          /* Если *var_c1[1] == '2' , то */
            lesson_2();                                     /* обратиться к функции lesson_2 и */
            break;                                          /* прервать анализ переменной *var_c1[1]. */
        case '3' :                                          /* Если *var_c1[1] == '3' , то */
            lesson_3();                                     /* обратиться к функции lesson_3 и */
            break;                                          /* прервать анализ переменной *var_c1[1]. */
        case '4' :                                          /* Если *var_c1[1] == '4' , то */
            lesson_4();                                     /* обратиться к функции lesson_4 и */
            break;                                          /* прервать анализ переменной *var_c1[1]. */
        case '5' :                                          /* Если *var_c1[1] == '5' , то */
            lesson_5();                                     /* обратиться к функции lesson_5 и */
            break;                                          /* прервать анализ переменной *var_c1[1]. */
        case '6' :                                          /* Если *var_c1[1] == '6' , то */
            lesson_6();                                     /* обратиться к функции lesson_6 и */
            break;                                          /* прервать анализ переменной *var_c1[1]. */
        case '7' :                                          /* Если *var_c1[1] == '7' , то */
            lesson_7();                                     /* обратиться к функции lesson_7 и */
            break;                                          /* прервать анализ переменной *var_c1[1]. */
        case '8' :                                          /* Если *var_c1[1] == '8' , то */
            lesson_8();                                     /* обратиться к функции lesson_8 и */
            break;                                          /* прервать анализ переменной *var_c1[1]. */
        case '9' :                                          /* Если *var_c1[1] == '9' , то */
            lesson_9();                                     /* обратиться к функции lesson_9 и */
            break;                                          /* прервать анализ переменной *var_c1[1]. */
        default :                                           /* В остальных случаях */
            printf("Input symbol argument 1 ... 9\n");      /* напечатать "Input symbol argument 1 ... 9" и */
            break;                                          /* прервать анализ переменной *var_c1[1]. */
    }

    printf("\n\n");

    return 0;                                               /* Успешное завершение программы. Возврат результата 0 типа int. */
}                                                           /* Возврат строки в конце кода */
