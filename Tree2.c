/* Программа строит бинарное дерево из слов и печатает их в лексиграфическом порядке с указанием количества повторений */
/* Тестовая фраза: now is the time for all good men to come to the aid of their party */
/* В конце дерево ликвидируется с контролем удаления узлов */



#include <stdio.h>
#include <stdlib.h>
#define MAXWORD 20												/* Максимальное количество символов в слове */
#define MAXSTRING 400											/* Максимальное количество символов в строке входного потока */

typedef struct node												/* Структура узла */
{
	char *WORD;
	int COUNT;
	struct node *LEFT;
	struct node *RIGHT;
} knot;

void getword(char *PTSTRING, int LEN)							/* Функция заполняет массив по указателю *PTSTRING очередным словом */
																/* из входного потока. Если длина слова превышает максимум LEN */
																/* или символ не принадлежит ASCII, то */
																/* выдаётся сообщение об ошибке и функция останавливается. */
																/* Если прочитаны все символы строки, то последний символ слова */
																/* равен 0, иначе последний символ слова равен ' ' */
{
char *PTC;														/* Вспомогательная переменная */
char VCHAR2;													/* Вспомогательная переменная */
int I=0;														/* Счётчик символов в слове */

	PTC=PTSTRING;												/* Запомнить адрес начала выходного массива */
	VCHAR2=getchar();											/* Читаем первый символ */
	while (VCHAR2==' '||VCHAR2=='\t') VCHAR2=getchar();			/* Пропускаем пробелы и табуляции */
	while (VCHAR2>32&&VCHAR2<127&&I<LEN-1)						/* Пока читаются буквы ASCII и счётчик символов не переполнен */
	{
		*PTSTRING=VCHAR2;										/* Заполняем массив прочитаной буквой */
		PTSTRING++;												/* Смещаем указатель на следующий элемент массива */
		I++;													/* Увеличиваем счётчик символов */
		VCHAR2=getchar();										/* Считываем следующий символ */
	}
	if ((VCHAR2<32||VCHAR2>126)&&VCHAR2!='\t'&&VCHAR2!='\n')	/* Если символ не ASCII, не ' ', не '\t', и не '\n', то */
	{
		VCHAR2='\n';											/* Считаем, что прочитали последний символ; */
		PTSTRING=PTC;											/* Смещаем указатель на начальный элемент массива */
		printf("\n");
		printf("Unknoun symbol\n");								/* Вывод сообщения об ошибке */
		I=0;													/* Сброс счётчика символов */
	}
	if (I==LEN-1&&VCHAR2!='\n'&&VCHAR2!=' '&&VCHAR2!='\t')		/* Если счётчик символов в слове закончился и следующий символ не разделительный,*/
	{
		printf("\n");
		printf("Very long word in frase\n");					/* Вывод сообщения об ошибке */
		PTSTRING=PTC;											/* Смещаем указатель на начальный элемент массива */
		VCHAR2='\n';											/* Меняем последний прочитанный символ на разделительный */
	}
	if (VCHAR2=='\n') VCHAR2=0; else VCHAR2=' ';				/* Если разделительный символ '\n', то заменить его на 0 иначе на ' ' */
	*PTSTRING=VCHAR2;											/* Завершить слово */
}

int strcmp(char *PTONE, char *PTTWO)										/* Функция сравнения строк. Возвращает 0, если строки равны, 1 если первая строка больше второй и -1, если меньше */
{
int I=0;																	/* Априорно слова равны */

	for (;*PTONE==*PTTWO&&*PTONE>32&&*PTONE<127; PTONE++) PTTWO++;			/* Пока символы равны, двигаемся по строкам */
	if (*PTONE>32&&*PTONE<127&&*PTTWO>32&&*PTTWO<127)						/* если в обоих строках символы, то */
		if (*PTONE>*PTTWO) I++; else I--;										/* если  в первой строке символ больше, чем во сторой, I=1 иначе I=-1 */
	else																	/* иначе */
		if (*PTONE>32&&*PTONE<127&&(*PTTWO<33||*PTTWO>126)) I++;				/* Если в второй строке разделительный символ, а в первой  - нет, то I=1 */
		else if (*PTTWO>32&&*PTTWO<127&&(*PTONE<33||*PTONE>126)) I--;			/* иначе если в первой строке разделительный символ, а во второй- нет, то I=-1 */
	return I;																/* (если в обоих строках символы разделительные, но разные, то I=0 априорно) */
}

knot *addtree(knot *PT, char *PW)								/* Функция создаёт и выращивает дерево по указателю PT из слов по указателю PW */
{
int I;

	if (PT==NULL)												/* Если узла ещё нет, то */
	{
		PT=malloc(sizeof(knot));								/* Выделить память для узла дерева */
		if (PT!=NULL);											/* Если память выделена, то */
		{
			PT->WORD=PW;										/* Инициализация полей узла */
			PT->COUNT=1;
			PT->LEFT=PT->RIGHT=NULL;
		}
	} else														/* Если дерево уже есть */
		switch (I=strcmp(PW, PT->WORD))							/* Сравнить слово аргумента со словом в узле */
		{
			case 0	: PT->COUNT++; break;						/* Если равны, то слово уже встречалось */
			case 1	: PT->RIGHT=addtree(PT->RIGHT, PW); break;	/* Если больше, перейти в правый узел */
			default : PT->LEFT=addtree(PT->LEFT, PW); break;	/* Если меньше, перейти в левый узел */
		}
	return PT;													/* Вернуть указатель на дерево */
}

knot *deltree(knot *PT)
{
	if ((PT->LEFT)!=NULL) PT->LEFT=deltree(PT->LEFT);						/* Если левый узел не пуст, удалить его */
	if ((PT->RIGHT)!=NULL) PT->LEFT=deltree(PT->RIGHT);						/* Если правый узел не пуст, удалить его */
	printf("deleted ");												/* Напечатать слово, узел которого удаляется */
	for (; *PT->WORD!=' '&&*PT->WORD!=0; PT->WORD++) printf("%c", *PT->WORD);
	printf("\n");
	free(PT);														/* Освободить память, выделенную для этого узла */
	return	NULL;													/*Вернуть пустой адрес этого узла */
}

void treeprint(knot *PT)
{
char *PW;
	if (PT!=NULL)														/* Если узел не пуст, то */
	{
		treeprint(PT->LEFT);											/* напечатать левый узел, затем */
		printf("%4d\t", PT->COUNT);										/* напечатать количество повторений слова */
		for (PW=PT->WORD; *PW!=' '&&*PW!=0; PW++) printf("%c", *PW);	/* Напечатать слово */
		printf("\n");
		treeprint(PT->RIGHT);											/* Напечатать правый узел */
	}
	return;
}

void main()
{
char STRING[MAXSTRING];											/* Массив строки (куда будут помещаться слова) */
char *PTS1;	 													/* PTS1 - указатель на массив STRING */
char *PTW1;														/* Вспомогательные переменные */
knot *PTTREE;													/* Указатель на дерево */
int I;															/* Вспомогательные переменные циклов */

	PTTREE=NULL;
	I=0;
	PTS1=&STRING[0];
	printf("\n");
	printf("Input frase\n");
	do
	{
		if ((&STRING[0]+MAXSTRING*sizeof(char))<(PTS1+MAXWORD*sizeof(char)))	/* Если места для следующего слова может не хватить, то */
		{
			printf("My be few memory fo next word");			/* вывести сообщение об ошибке */
			break;												/* и прервать цикл */
		}
		getword(PTS1, MAXWORD);									/* Получаем очередное слово и записываем его в массив STRING */
		if (*PTS1==0) break;									/* Если слово пустое, прервать цикл */
		PTTREE=addtree(PTTREE,PTS1);							/* Добавить слово в дерево */
		if (PTTREE==NULL)										/* Если указатель пуст, то */
		{
			printf("No memori in computer\n");					/* вывести сообщение об ошибке */
			break;												/* и прервать цикл */
		}
		for (; *PTS1!=' '&&*PTS1!=0; PTS1++);					/* Передвигаем указатель до конца слова на пустое место */
		PTW1=PTS1;												/* Запоминаем адрес последнего символа последнего слова */
		PTS1++;													/* и далее на пустое место */
		*PTS1=0;												/* Инициализируем первую свободную ячейку как конец слова */
	}
	while (*PTW1!=0);											/* Если последний символ последнего слова 0, завершаем обработку входного потока */
	printf("\n");
	for (I=0; STRING[I]!=0; I++) printf("%c", STRING[I]);		/* Вывод фразы из массива STRING */
	printf("\n\n");
	treeprint(PTTREE);											/* Печать слов в лексиграфическом порядке с количеством повторений */
	printf("\n");
	PTTREE=deltree(PTTREE);										/* Освобождение памяти */
}
